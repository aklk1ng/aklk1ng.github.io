---
title: Makefile/GDB（未完待续）
date: 2022-06-16 19:43:44
tags:
---

# Makefile与GDB

## 1.Makefile

### 0.Make

* 一个解释makefile中指令的命令工具

makefile带来的好处是——**自动化编译**，编写好后只需make命令，整个工程完全自动编译

### 1.规则

每条规则的语法格式：

``` shell
target1,target2...:depend1,depend2,...
	command
	......
	......
```



#### 1.1目标

* 目标与命令是相对应的
* 通过执行规则的命令，可以执行动作但不生成任何文件，这样的目标被称为伪目标

#### 1.2依赖

* 若不需要依赖，可以不声明
* 可以形成嵌套，也可以是多个依赖

#### 1.3命令

* 一般情况下为shell指令
* 每一个命令必须有一个tab缩进，且独占一行

### 2.工作原理

#### 2.1规则的执行

**在调用make命令编译程序的时候，make会首先找到Makefile文件中的第一个规则，分析并执行相关的动作**

make命令执行的时候会根据文件的时间戳判断是否执行makefile文件中相关的命令

* 正常情况下：**目标时间戳>依赖时间戳**，如果执行make命令的时候检测到规则中的目标和依赖满足这个条件，那么规则的命令不会被执行
* 如果**目标时间戳<依赖时间戳**，在这种情况下会重新生成命令
* 如果规则中的目标对应的文件根本不存在，规则中的命令肯定会执行

#### 2.2文件的时间戳



#### 2.3自动推导

**make中会进行一定的自动推导进行完善编译的逻辑性，不会完全依赖makefile**

### 3.变量

#### 3.1自定义变量

用户自己定义的变量，**makefile中变量没有类型**，直接创建然后使用即可

#### 3.2预定义变量

| 变量名   | 含义                      | 默认值   |
| -------- | ------------------------- | -------- |
| AR       | 生成静态库文件的程序名称  | ar       |
| AS       | 汇编编译器的名称          | as       |
| CC       | C语言编译器的名称         | cc       |
| CPP      | C语言预编译器的名称       | $(CC) -E |
| CXX      | C++语言编译器的名称       | g++      |
| FC       | FORTRAN语言编译器的名称   | f77      |
| RM       | 删除文件程序的名称        | rm -f    |
| CFLAGS   | C语言编译器的编译选项     | 无默认值 |
| CPPFLAGS | C++语言预编译器的编译选项 | 无默认值 |
| CXXFLAGS | c++语言编译器的编译选项   | 无默认值 |

#### 3.3自动变量

自动变量用来表示这些规则中的目标文件和依赖文件，并且**只能在规则的命令中使用**

| 变量   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| $*     | 表示目标文件的名称，不包含文件的拓展名                       |
| $+     | 表示所有的依赖文件，这些依赖文件以空格分开，按照出现的先后顺序，其中可能包含重复的依赖文件 |
| $<     | 表示依赖项中第一个依赖文件的名称                             |
| $?     | 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 |
| **$@** | **表示目标文件的名称，包含文件的拓展名**                     |
| **%^** | **依赖项中，所有不重复的依赖文件，文件之间以空格分开**       |

### 4.模式匹配

通过一个规则模板(**一定要使用自动变量**)：

``` makefile
%.o:%.c
	gcc $< -c
```

### 5.函数

#### 5.1wildcard

***获取指定目录下指定类型的文件，其返回值以空格分开***

**函数原型：**

``` makefile
$(wildcard PATTERN...)
			#参数：	指定某个目录，搜索这个路径下指定类型的文件
```

* 参数功能：
    * PATTERN指的是某个或多个目录下的对应的某种类型的文件
    * 可以指定多个目录，路径之间用空格分开
* 返回值：
    * 得到的若干个文件的文件列表，文件民之间用空格分开

#### 5.2patsubst

***按照指定的模式替换指定文件民的后缀***

**函数原型：**

``` makefile
$(patsubst <pattern>,<replacement>,<text>)
			#指定的文件名	替换后的文件名	文件来源
```



* 参数功能：
    * pattern：模式字符串，指定被替换文件名的后缀
        * 文件名与路径不关心，使用%表示即可
        * 在通配符后要指定要被替换掉后缀
    * replacement：模式字符串，指定参数pattern被替换后的后缀名
        * 依旧使用%表示文件名
        * 在通配符后指定新的后缀名
    * text：存储被替换的原始数据
* 返回值：
    * 函数返回被替换过后的字符串

**示例：**

``` makefile
src1=a.cpp b.cpp c.cpp
src2=$(patsubst %.cpp,%.c,$(src1))
# src2的值为：a.c b.c c.c
```

### 6.makefile的编写

#### 伪目标

**让makefile工具不去比较目标文件与依赖文件的时间戳**

在makefile中声明一个伪目标要使用`<.PHONY>`关键字

声明方式：**.PHONY:伪目标名称**

#### Tips：

shell命令前的`-`可以让程序即使执行失败该条命令也不会终止，继续执行下一条命令

## 2.GDB

gdb也是GNU软件系统社区提供的调试器

**gdb是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序**

### 1.调试准备

项目如果是为了进行调试而编译时，必须要打开调试选项`gcc -g`，可选的选项为`-o0` `-Wall`

### 2.启动和退出gdb

#### 2.1启动gdb

**在启动gdb进程后，被调试的程序没有被执行**

直接在可执行程序的目录下执行gdb即可启动

#### 2.2命令行传参

```shell
(gdb)	set args	#参数1	参数2 .。。。	设置参数

(gdb)   show args   #查看设置的命令行参数
```

#### 2.3gdb中启动程序

**在gdb中，run命令和start命令只能执行一次**

``` shell
(gdb)run/r #如果程序设置了断点，会在第一个断点处停下，否则执行全部
(gdb)start #只执行mian函数的第一行命令，等待输入后续其他gdb命令，如果还想让程序在start之后继续运行，或者在断点后继续运行，可以使用 continue/c 命令
```

#### 2.4退出gdb

``` shell
(gdb) quit/q
```

### 3.查看代码

#### 3.1当前文件

``` shell
(gdb)	list		  #从第一行开始显示	查看代码信息位于程序入口函数main所在的文件中，如果不进行文件切换main函数所在的文件就是当前文件
(gdb)	list 行号		 #显示行号对应的上下文内容，默认只显示10行
(gdb)	list 函数名	#显示函数的上下文内容，默认只显示10行
#如果还想继续查看代码，可以继续执行list命令也可以直接回车(会执行上一次执行的gdb命令)
```

#### 3.2切换文件

``` shell
(gdb) l 文件名:行号	#切换到指定文件中的对应行号的上下文内容，默认只显示10行
(gdb) l 文件名:函数名 #切换到指定文件名中的指定函数上下文内容，默认只显示10行
```

#### 3.3设置显示的行数

``` shell
#以下的listsize可以更换为list
(gdb) set listsize 行数	#设置一次显示的行数
(gdb) show listsize       #显示行数
```

### 4.断点操作

#### 4.1设置断点

* 设置普通断点到当前文件

    ``` shell
    #break==b
    (gdb) b 行号
    (gdb) b 函数名	#停止在函数的第一行
    ```

    

* 设置普通断点到某个非当前文件上

    ``` shell
    (gdb) b 文件名:行号
    (gdb) b 文件名:函数名
    ```

* 设置条件断点

    ``` shell
    #必须要满足某个条件，程序才会停止在这个断点的位置上
    #通常情况下在循环内使用
    (gdb) b 行数 if 变量==某个值
    ```

#### 4.2查看断点

``` shell
#info == i
#查看设置的断点信息
(gdb) i b #info break
# 举例
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400cb5 in main() at test.cpp:12
2       breakpoint     keep y   0x0000000000400cbd in main() at test.cpp:13
3       breakpoint     keep y   0x0000000000400cec in main() at test.cpp:18
4       breakpoint     keep y   0x00000000004009a5 in insertionSort(int*, int) 
                                                   at insert.cpp:8
5       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16
6       breakpoint     keep y   0x00000000004009e5 in insertionSort(int*, int) 
                                                   at insert.cpp:16
#Num: 断点的编号，删除断点或者设置断点状态的时候都需要使用
#Enb: 当前断点的状态，y 表示断点可用，n 表示断点不可用
#What: 描述断点被设置在了哪个文件的哪一行或者哪个函数上
```

#### 4.3删除断点

``` shell
# delete == del == d
# 需要 info b 查看断点的信息, 第一列就是编号
(gdb) d 断点的编号1 [断点编号2 ...]
# 举例: 
(gdb) d 1          # 删除第1个断点
(gdb) d 2 4 6      # 删除第2,4,6个断点

# 删除一个范围, 断点编号 num1 - numN 是一个连续区间
(gdb) d num1-numN
# 举例, 删除第1到第5个断点
(gdb) d 1-5
```

#### 4.4设置断点状态

* 设置断点无效

    ``` shell
    # 让断点失效之后, gdb调试过程中程序是不会停在这个位置的
    # disable == dis
    # 设置某一个或者某几个断点无效
    (gdb) dis 断点1的编号 [断点2的编号 ...]
    
    # 设置某个区间断点无效
    (gdb) dis 断点1编号-断点n编号
    ```

* 让无效的断点生效

    ``` shell
    # enable == ena
    # 设置某一个或者某几个断点有效
    (gdb) ena 断点1的编号 [断点2的编号 ...]
    
    # 设置某个区间断点有效
    (gdb) ena 断点1编号-断点n编号
    ```

    

### 5.调试命令

#### 5.1继续运行gdb

``` shell
# continue == c
(gdb) continue
```

#### 5.2手动打印信息

**当程序被某个断点阻塞之后，可以通过一些命令打印变量的名字或变量的类型，并且还可以跟踪打印某个变量的值**

##### 5.2.1打印信息值

| 格式化字符(/fmt) | 说明                               |
| ---------------- | ---------------------------------- |
| **/x**           | 以十六进制的形式打印出整数         |
| **/d**           | 以有符号、十进制的形式打印出整数   |
| **/u**           | 以无符号、十进制的形式打印出整数   |
| **/o**           | 以八进制的形式打印出整数           |
| **/t**           | 以二进制的形式打印出整数           |
| **/f**           | 以浮点数的形式打印变量或表达式的值 |
| **/c**           | 以字符形式打印变量或表达式的值     |

* print命令语法格式：

    ``` shell
    # print == p
    (gdb) p 变量名
    
    # 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表
    (gdb) p/fmt 变量名
    ```

    

##### 5.2.2打印变量类型

``` shell
# 语法格式
(gdb) ptype 变量名

# 打印变量类型
(gdb) ptype i
type = int
(gdb) ptype array[i]
type = int
(gdb) ptype array
type = int [12]
```



#### 5.3自动打印信息

##### 5.3.1设置变量名自动显示

``` shell
# 在变量的有效取值范围内, 自动打印变量的值(设置一次, 以后就会自动显示)
(gdb) display 变量名

# 以指定的整形格式打印变量的值, 关于 fmt 的取值, 请参考 print 命令
(gdb) display/fmt 变量名
```

##### 5.3.2查看自动显示列表

``` shell
# info == i
(gdb) info display
Auto-display expressions now in effect:
Num Enb Expression
1:   y  i
2:   y  array[i]
3:   y  /x array[i]
#Num : 变量或表达式的编号，GDB 调试器为每个变量或表达式都分配有唯一的编号
#Enb : 表示当前变量（表达式）是处于激活状态还是禁用状态，如果处于激活状态（用 y 表示），则每次程序停止执行，该变量的值都会被打印出来；反之，如果处于禁用状态（用 n 表示），则该变量（表达式）的值不会被打印。
#Expression ：被自动打印值的变量或表达式的名字
```

##### 5.3.3取消自动显示

* 删除自动显示列表中的变量或表达式

    ```shell
    # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
    (gdb) undisplay num [num1 ...]
    # num1 - numN 表示一个范围
    (gdb) undisplay num1-numN
    
    (gdb) delete display num [num1 ...]
    (gdb) delete display num1-numN
    
    #举例
    # 查看显示列表
    (gdb) info display
    Auto-display expressions now in effect:
    Num Enb Expression
    1:   y  i
    2:   y  array[i]
    3:   y  /x array[i]
    
    # 删除变量显示, 需要使用 info display 得到的变量/表达式编号
    (gdb) undisplay 1 2
    
    # 查看显示列表, 只剩下一个了
    (gdb) i display
    Auto-display expressions now in effect:
    Num Enb Expression
    3:   y  /x array[i]
    ```

* 禁用自动显示列表中处于激活状态的变量或表达式

    ``` shell
    # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
    (gdb) disable display num [num1 ...]
    # num1 - numN 表示一个范围
    (gdb) disable display num1-numN
    ```

* 启用自动显示列表中被禁用的变量或表达式

    ``` shell
    # 命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个
    (gdb) enable  display num [num1 ...]
    # num1 - numN 表示一个范围
    (gdb) disable display num1-numN
    ```

    

#### 5.4单步调试

**当程序阻塞到某个断点上之后，可以通过以下命令对程序进行单步调试**

##### 5.4.1step

``` shell
# 从当前代码行位置, 一次调试当前行下的每一行代码
# step == s
# 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部
(gdb) step
```

##### 5.4.2 finish

``` shell
# 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体
#如果函数体内存在有效断点，则无法跳出
(gdb) finish
```

##### 5.4.3next

``` shell
# next == n
# 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部
(gdb) next
```

##### 5.4.4until

**使用`until`命令可以直接跳出循环体，但有两个满足的条件：**

1. **要跳出的循环体内部不能有有效的断点**
2. **必须要在循环体的开始/结束行执行该命令**

``` shell
(gdb) until
```

#### 5.5设置变量值

**使用以下方式可以直接对虚幻条件的哦按段**

``` shell
# 可以在循环中使用, 直接设置循环因子的值
# 假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90
(gdb) set var 变量名=值
```

